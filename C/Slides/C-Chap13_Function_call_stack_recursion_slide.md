---
marp: true
theme: gaia
size: 16:9
paginate: true
lang: ko-KR
footer: Taehyun Kim ( thkim@legacylab.pro )
---

# C 언어 Chapter 13: 함수 호출, 스택 프레임, 재귀

---

## 오늘 목표
- 함수 호출이 Stack에서 어떻게 처리되는지 설명한다
- C의 값 전달과 포인터 전달을 정확히 구분한다
- 재귀 함수의 종료 조건과 호출 흐름을 이해한다
- 스택 오염(Stack Corruption) 위험을 개념적으로 이해한다

---

## 진행 순서
1. 함수 호출과 스택 프레임
2. Call by Value vs 포인터 전달
3. 재귀(Recursion)
4. Stack Corruption 개념
5. 실습과 체크포인트

---

## 함수 호출의 큰 흐름
```c
int main(void) {
    int r = add(2, 3);
    return r;
}
```

- `main`이 `add`를 호출
- CPU는 `add`로 점프하고, 끝나면 다시 `main`으로 복귀

---

## 스택 프레임(Stack Frame)
- 함수 1회 호출마다 스택 프레임 1개 생성
- 스택 프레임에는 보통 다음 정보가 포함됨
- 매개변수, 지역 변수, 복귀 주소(return address), 저장 레지스터

---

## 호출 시 메모리 그림
```text
높은 주소
+------------------+
| main frame       |
+------------------+
| add frame        |  <- 현재 실행 중
+------------------+
낮은 주소
```

- 함수가 끝나면 해당 프레임은 제거됨

---

## Call by Value (C의 기본)
```c
void inc(int x) { x++; }

int a = 10;
inc(a);  // a는 그대로 10
```

- 인자 `a`의 "값 복사본"이 `x`로 전달됨

---

## 포인터 인자도 여전히 Value 전달
```c
void set_zero(int *p) { *p = 0; }

int a = 10;
set_zero(&a);  // a가 0으로 바뀜
```

- 전달되는 것은 주소값의 복사본
- 그 주소가 같은 메모리를 가리켜 원본이 바뀌는 것

---

## C에서의 "Call by Reference"
- C 문법에는 진짜 참조 전달이 없음
- 포인터를 사용해 참조 전달처럼 동작하게 만듦
- 수업에서는 "포인터를 이용한 간접 수정"으로 표현 권장

---

## 재귀(Recursion)란?
- 함수가 자기 자신을 다시 호출하는 방식
- 핵심 2가지:
- 종료 조건(Base Case)
- 재귀 호출(Recursive Case)

---

## 재귀 예제: 팩토리얼
```c
int fact(int n) {
    if (n <= 1) return 1;       // 종료 조건
    return n * fact(n - 1);     // 재귀 호출
}
```

---

## fact(4) 호출 추적
```text
fact(4)
 -> 4 * fact(3)
 -> 4 * 3 * fact(2)
 -> 4 * 3 * 2 * fact(1)
 -> 4 * 3 * 2 * 1
```

- 내려갈 때 호출 프레임이 쌓이고
- 올라올 때 반환값이 계산됨

---

## 재귀의 장단점
- 장점: 문제 정의와 코드 구조가 맞으면 읽기 쉬움
- 단점: 호출 오버헤드, 깊은 호출 시 스택 사용량 증가
- 종료 조건이 없으면 무한 재귀로 비정상 종료

---

## Stack Overflow
- 재귀 깊이가 너무 크면 스택 공간을 초과
- 대표 증상: 프로그램 강제 종료, 예외 발생
- 방지: 종료 조건 검증, 반복문으로 대체 가능한지 검토

---

## Stack Corruption 개념
- 스택 영역의 메모리가 의도치 않게 손상된 상태
- 원인 예: 경계 체크 없는 배열 쓰기

```c
void bad(void) {
    char buf[8];
    // buf 범위를 넘어 쓰면 인접 스택 데이터 손상 가능
}
```

---

## 왜 위험한가
- 지역 변수 값이 깨질 수 있음
- 함수 복귀 흐름이 비정상 동작할 수 있음
- 프로그램 크래시, 보안 취약점으로 이어질 수 있음

---

## 기본 방어 수칙
- 배열 경계 체크 습관화
- `gets` 같은 위험 함수 사용 금지
- 길이 제한이 있는 입력 함수 사용 (`fgets`, 폭 지정 `scanf`)
- 컴파일러 보호 옵션 사용 (`-fstack-protector`)

---

## 실습 1: 값 전달 vs 포인터 전달
요구사항:
- `inc_value(int x)`와 `inc_ptr(int *p)`를 각각 구현
- 호출 전/후 값을 출력해 차이 확인

---

## 실습 2: 재귀 합계 함수
요구사항:
- `sum_to_n(int n)` 작성
- `n + (n-1) + ... + 1` 계산
- `n <= 0` 처리 포함

---

## 실습 3: 재귀 깊이 관찰
요구사항:
- 함수에 호출 깊이 인자를 추가
- 호출/복귀 시 깊이를 출력
- 어떤 순서로 스택이 쌓이고 빠지는지 확인

---

## 체크포인트
- 스택 프레임에 어떤 정보가 들어가는지 설명할 수 있나요?
- C의 전달 방식이 왜 Value인지 설명할 수 있나요?
- 재귀의 종료 조건이 왜 필수인지 설명할 수 있나요?
- 스택 오염이 위험한 이유를 말할 수 있나요?

---

## 정리
- 함수 호출은 스택 프레임 단위로 관리된다
- C는 기본적으로 값 전달 언어다
- 포인터는 원본 메모리를 간접 수정하게 해준다
- 재귀는 강력하지만 종료 조건과 깊이 관리가 필수다

---

## 다음 시간 예고
- 함수 포인터 실전
- 콜백(Callback)과 동적 로딩(Dynamic Loading)
