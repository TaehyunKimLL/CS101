---
marp: true
theme: gaia
size: 16:9
paginate: true
lang: ko-KR
footer: Taehyun Kim ( thkim@legacylab.pro )
---

# C 워크시트 Chapter 13: 함수 호출, 스택, 재귀

---

## 학습 목표
- 함수 호출 시 스택 프레임 변화를 관찰한다
- 값 전달과 포인터 전달의 차이를 코드로 확인한다
- 재귀의 종료 조건을 설계하고 검증한다

---

## 준비 코드
```c
#include <stdio.h>

void inc_value(int x) { x++; }
void inc_ptr(int *p) { (*p)++; }
```

---

## 실습 1: 값 전달 vs 포인터 전달
요구사항:
- `int a = 10;`으로 시작
- `inc_value(a)` 호출 전/후 `a` 출력
- `inc_ptr(&a)` 호출 전/후 `a` 출력

체크:
- [ ] 두 결과가 왜 다른지 설명할 수 있는가?

---

## 실습 2: 주소 출력으로 스택 관찰
요구사항:
- `main`, `foo`, `bar` 함수를 만든다
- 각 함수에서 지역 변수 주소를 출력한다
- 호출 순서: `main -> foo -> bar`

힌트:
```c
printf("foo local addr = %p\n", (void *)&x);
```

---

## 실습 3: 재귀 팩토리얼
요구사항:
- `int fact(int n)` 작성
- `n <= 1`에서 종료
- `fact(1)`, `fact(5)`, `fact(10)` 출력

체크:
- [ ] 종료 조건이 없으면 어떤 문제가 생기는가?

---

## 실습 4: 재귀 호출 깊이 출력
요구사항:
- `void trace(int n, int depth)` 작성
- 호출 직전/복귀 직전에 depth 출력
- `trace(3, 0)` 실행

목표:
- 스택이 "쌓였다가" "풀리는" 순서를 눈으로 확인

---

## 개념 점검: Stack Corruption
아래 질문에 답하세요.
1. 지역 배열 경계를 넘는 쓰기가 왜 위험한가?
2. 스택 프레임 안에서 어떤 데이터가 손상될 수 있는가?
3. 방어 방법 2가지를 적어라.

---

## 추가 도전
- 재귀로 배열 합(`sum(arr, n)`) 구현
- 반복문 버전과 비교:
- 코드 길이
- 읽기 쉬움
- 큰 입력에서의 안정성

---

## 제출 체크리스트
- [ ] 모든 코드가 컴파일되고 실행된다
- [ ] 실습 2에서 함수별 주소 출력 캡처를 남겼다
- [ ] 재귀 종료 조건을 명확히 주석으로 설명했다
- [ ] Stack Corruption 질문에 답했다
