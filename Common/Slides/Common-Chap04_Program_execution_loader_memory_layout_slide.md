---
marp: true
theme: gaia
size: 16:9
paginate: true
lang: ko-KR
footer: Taehyun Kim ( thkim@legacylab.pro )
---

# Common Chapter 4: 실행 파일, 로더, 메모리 레이아웃

---

## 오늘 목표
- 실행 파일이 프로세스로 바뀌는 과정을 설명한다
- 로더(Loader)의 역할을 이해한다
- 프로세스 메모리 레이아웃을 구분한다
- 함수 호출과 스택 사용을 실행 관점에서 연결한다

---

## 실행까지의 흐름
1. 디스크에 실행 파일이 존재
2. OS가 실행 요청을 받음
3. 로더가 파일을 메모리에 매핑
4. 진입점(entry point)으로 점프
5. `main` 호출 후 프로그램 실행

---

## 로더가 하는 일
- 실행 파일 형식 검사(PE/ELF/Mach-O)
- 코드/데이터 섹션 매핑
- 필요한 공유 라이브러리 로드
- 초기 스택/힙 상태 준비

---

## 프로세스 메모리 레이아웃(개념)
```text
높은 주소
[ Stack ]  <- 함수 호출, 지역 변수
[ Heap  ]  <- 동적 할당(malloc/new)
[ BSS   ]  <- 0으로 초기화되는 전역/정적
[ Data  ]  <- 초기값 있는 전역/정적
[ Text  ]  <- 기계어 코드(읽기 전용)
낮은 주소
```

---

## Text / Data / BSS
- Text: 실행 명령어
- Data: 초기값 있는 전역/정적 변수
- BSS: 초기값 없는 전역/정적 변수
- 메모리 구역 분리가 보호와 성능에 중요

---

## Stack과 함수 호출
- 함수 호출 시 스택 프레임 생성
- 프레임에 매개변수/지역변수/복귀 정보 저장
- 함수 종료 시 프레임 제거

---

## Heap과 동적 메모리
- 실행 중 크기가 바뀌는 데이터에 사용
- `malloc/free`로 직접 관리
- 해제 누락 시 메모리 누수 발생

---

## 프로그램 시작 시 인자
```c
int main(int argc, char **argv)
```

- `argc`: 인자 개수
- `argv`: 인자 문자열 배열
- 로더/런타임이 초기 값 구성

---

## 사용자 모드와 커널 모드
- 일반 코드: 사용자 모드
- 파일/네트워크/프로세스 제어는 시스템 콜로 요청
- OS 커널이 권한 있는 작업 수행

---

## 실행 중 자주 만나는 오류
- Segmentation Fault: 잘못된 메모리 접근
- Stack Overflow: 과도한 재귀/큰 지역 배열
- Abort: 런타임 검증 실패로 강제 종료

---

## 관찰 포인트
- 같은 코드라도 OS/컴파일 옵션에 따라 메모리 배치 차이 존재
- 디버거로 함수 호출 스택(Call Stack)을 추적 가능
- 메모리 문제는 "어디에 저장됐는지"로 접근하면 빨리 해결

---

## 실습 제안
- 지역 변수/전역 변수/동적 할당 주소를 각각 출력
- 주소 대역이 다른지 확인
- 재귀 함수 호출 시 깊이에 따른 주소 변화를 관찰

---

## 체크포인트
- 로더가 실행 전에 하는 일을 설명할 수 있나요?
- Text/Data/BSS/Heap/Stack 차이를 말할 수 있나요?
- 함수 호출과 스택 프레임의 관계를 설명할 수 있나요?
- Stack Overflow가 왜 발생하는지 설명할 수 있나요?

---

## 정리
- 실행 파일은 로더를 거쳐 프로세스가 된다
- 메모리 구역마다 역할과 수명이 다르다
- 함수 호출은 스택 기반으로 동작한다
- 메모리 레이아웃 이해는 디버깅의 출발점이다
